# 쿼리 튜닝

---

# 1) 현상 정의 & 측정 세팅

* **SLA·목표치 확정**: 예) 특정 API P95 < 200 ms, DB 평균 응답 < 20 ms.
* **SQL 로그·슬로우 쿼리 포착**

  * 손쉬운 방법: `datasource-proxy` 또는 `p6spy` 적용 → 바인딩 파라미터까지 로그, 슬로우쿼리 임계값 설정 가능. ([jdbc-observations.github.io][1])
  * **애플리케이션 메트릭**: Actuator+Micrometer로 `Timer`/DB 커넥션 지표 노출(프로메테우스 등). ([Home][2])
* **재현 쿼리 확보**: 느린 엔드포인트 호출 → 실제 SQL 캡처(파라미터 포함) → 단독 재현용 SQL로 분리.

예시(`application.yml`):

```yaml
decorator:
  datasource:
    datasource-proxy:
      logging: slf4j
      slow-query:
        enable-logging: true
        threshold: 200        # ms
management.endpoints.web.exposure.include: health,metrics,prometheus
```

(데코레이터 설정은 gavlyukovskiy 프로젝트가 자동 구성 지원) ([GitHub][3])

---

# 2) 실행 계획(Explain)으로 병목 파악

* **MySQL**: `EXPLAIN [ANALYZE] FORMAT=JSON|TREE <쿼리>` → 접근 방식(type), 사용/미사용 인덱스, 조인 순서·cost, rows, filtered 확인. `TREE`/`ANALYZE`가 가장 설명력이 좋습니다. ([MySQL][4])
* **PostgreSQL**: `EXPLAIN (ANALYZE, BUFFERS) <쿼리>` → Seq Scan vs Index Scan, 조인 알고리즘, 실제 시간/루프 횟수, 버퍼 I/O 분석. ([PostgreSQL][5])

핵심 체크:

* 풀스캔/잘못된 조인 순서?
* 조건절·정렬열에 **적절한 복합 인덱스**가 있는지?
* `ORDER BY/LIMIT`이 인덱스로 해결되는지(파일 정렬/소트 발생 여부)?

---

# 3) 스키마 & 인덱스 튜닝

* **선택도 높은 컬럼부터** 복합 인덱스 구성, **프리픽스 규칙** 준수.
* **WHERE + ORDER BY**를 한 번에 해결할 **커버링/복합 인덱스** 설계(예: `WHERE status=? AND created_at>? ORDER BY created_at DESC LIMIT ?`). MySQL `EXPLAIN`으로 소트·임시 테이블 제거 여부 확인. ([MySQL][6])
* PostgreSQL은 필요 시 **파셜(부분) 인덱스**·**다중컬럼 인덱스 순서** 고려, `EXPLAIN (ANALYZE)`로 검증. ([PostgreSQL][5])

예시(MySQL):

```sql
CREATE INDEX ix_order_status_created_at ON orders (status, created_at DESC);
EXPLAIN ANALYZE SELECT id FROM orders
 WHERE status='PAID' AND created_at > '2025-09-01'
 ORDER BY created_at DESC LIMIT 50;
```

---

# 4) 쿼리 자체 최적화

* **SELECT 최소화**: 엔티티 전체 대신 **프로젝션/DTO**로 필요한 컬럼만. Spring Data JPA의 인터페이스/클래스 프로젝션을 활용. ([Home][7])

  ```java
  interface OrderView { Long getId(); String getStatus(); Instant getCreatedAt(); }
  List<OrderView> findTop50ByStatusAndCreatedAtAfterOrderByCreatedAtDesc(String status, Instant after);
  ```
* **페이지네이션**: 대량 페이지에서 `OFFSET` 지연 발생 시 **키셋 페이지네이션**(커서 기반)으로 전환.

  1. ID 커서 확보 → 2) `WHERE id < :cursor ORDER BY id DESC LIMIT :size`.
     참고: 페치 조인과 페이지네이션을 무작정 결합하면 비효율/중복·메모리 폭등. 대안: **두 단계 조회(IDs → 연관 로딩)** 또는 최신 Hibernate 기능(케이스별) 고려. ([Vlad Mihalcea][8])

---

# 5) JPA/Hibernate 레이어 최적화 (N+1, 페치 전략)

* **N+1 탐지 → 제거**

  * 우선 기본은 `LAZY`. 필요한 경우에만 **`@EntityGraph`** 또는 \*\*`JOIN FETCH`\*\*로 한 번에 로딩. 컬렉션 페치+페이지 조합은 제한/부작용이 있으므로 주의. ([Home][9])
  * \*\*프로젝션(DTO)\*\*로 조인 데이터 한 번에 가져오면 N+1을 원천 차단. ([Home][7])
* **Batch Fetching**

  * 읽기 N+1 완화: `@BatchSize(size=50)` 또는 `hibernate.default_batch_fetch_size`로 지연로딩을 묶어 가져오기. ([docs.jboss.org][10])
* **쓰기 성능(대량 INSERT/UPDATE)**

  * JDBC 배치 활성화:

    ```properties
    spring.jpa.properties.hibernate.jdbc.batch_size=50
    spring.jpa.properties.hibernate.order_inserts=true
    spring.jpa.properties.hibernate.order_updates=true
    ```

    *주의*: **IDENTITY 전략**은 드라이버 배치를 제한할 수 있음(시퀀스/할당 전략이 유리). ([docs.jboss.org][11])

---

# 6) 커넥션 풀(HikariCP) 튜닝

* **기본값으로 시작 후 관찰 → 점진 조정**. 일반적으로 노드당 8\~16 커넥션이 적절한 출발점. **CPU 코어 기반** 계산식(코어×2 + 디스크수)을 가이드로 삼되, 실제 부하/DB 한도와 함께 튜닝. ([GitHub][12])
* 주요 속성:

  ```yaml
  spring.datasource.hikari:
    maximumPoolSize: 16
    minimumIdle: 4
    connectionTimeout: 30000   # ms
    idleTimeout: 600000
    maxLifetime: 1800000
  ```

  (스프링 부트 3.x는 Hikari가 기본이며 공통 프로퍼티로 제어 가능) ([Baeldung on Kotlin][13])
* **커넥션 릭 감지**: `leakDetectionThreshold`로 누수 추적. ([Medium][14])

---

# 7) 검증 & 회귀 방지

* \*\*EXPLAIN(ANALYZE)\*\*로 개선 전후 계획·실행시간 비교(동일 파라미터).
* **부하 테스트**(동시성↑)로 풀 포화·락·GC 영향 확인.
* **대시보드**: Micrometer 메트릭(커넥션 사용률, 쿼리 지연), 슬로우쿼리 로그를 패널화. ([Home][2])
* **통합 테스트**: 실제 DB(또는 Testcontainers)로 리그레션 방지. ([Medium][15])

---

# 8) 실전 적용 레시피 (케이스별 빠른 선택)

1. **WHERE+ORDER BY가 느림** → 복합 인덱스 정렬 포함 설계 → EXPLAIN으로 filesort/temporary 제거. ([MySQL][4])
2. **목록 API 대량 페이지 느림** → 키셋 페이지네이션 또는 두 단계 조회(IDs→상세). ([Vlad Mihalcea][8])
3. **N+1 발생** → `@EntityGraph`/프로젝션·필요시 제한적 `JOIN FETCH`(페이지와 혼용 주의). ([Home][9])
4. **대량 저장 느림** → JDBC 배치 + `order_inserts/updates` + ID 전략 점검. ([docs.jboss.org][11])
5. **DB 연결 대기** → Hikari `maximumPoolSize`·`connectionTimeout` 조정, 릭 감지. ([GitHub][12])

